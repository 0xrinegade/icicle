diff --git a/icicle/curves/curve_config.cuh b/icicle/curves/curve_config.cuh
index 68464e8..a250439 100644
--- a/icicle/curves/curve_config.cuh
+++ b/icicle/curves/curve_config.cuh
@@ -10,8 +10,10 @@
 typedef Field<fp_config> scalar_field_t;
 typedef scalar_field_t scalar_t;
 typedef Field<fq_config> point_field_t;
-typedef Projective<point_field_t, scalar_field_t, weierstrass_b> projective_t;
+static constexpr point_field_t b = point_field_t{ weierstrass_b };
+typedef Projective<point_field_t, scalar_field_t, b> projective_t;
 typedef Affine<point_field_t> affine_t;
 typedef ExtensionField<fq_config> g2_point_field_t;
-typedef Projective<g2_point_field_t, scalar_field_t, g2_weierstrass_b> g2_projective_t;
+static constexpr g2_point_field_t b2 = g2_point_field_t{ point_field_t {b_re},  point_field_t {b_im}};
+typedef Projective<g2_point_field_t, scalar_field_t, b2> g2_projective_t;
 typedef Affine<g2_point_field_t> g2_affine_t;
diff --git a/icicle/primitives/extension_field.cuh b/icicle/primitives/extension_field.cuh
index 5eab848..174790f 100644
--- a/icicle/primitives/extension_field.cuh
+++ b/icicle/primitives/extension_field.cuh
@@ -143,7 +143,7 @@ template <typename CONFIG> class ExtensionField {
     static constexpr HOST_DEVICE_INLINE ExtensionField inverse(const ExtensionField& xs) {
       ExtensionField xs_conjugate = { xs.real, FF::neg(xs.imaginary) };
       // TODO: wide here
-      FF xs_modulus_squared = FF::sqr(xs.real) + FF::sqr(xs.imaginary);
-      return xs_conjugate * ExtensionField { FF::inverse(xs_modulus_squared), FF::zero() };
+      FF xs_norm_squared = FF::sqr(xs.real) + FF::sqr(xs.imaginary);
+      return xs_conjugate * ExtensionField { FF::inverse(xs_norm_squared), FF::zero() };
     }
 };
diff --git a/src/field.rs b/src/field.rs
index 3b4d4d4..d87853c 100644
--- a/src/field.rs
+++ b/src/field.rs
@@ -1,15 +1,45 @@
 use std::ffi::c_uint;
-use std::mem::transmute;
+use std::ops::Mul;
 
-use ark_bls12_381::{Fq, G1Affine, G1Projective};
-use ark_ec::AffineCurve;
-use ark_ff::{BigInteger384, BigInteger256, PrimeField};
+// TODO: change curve here based on the features
+use ark_bls12_381::{Fq, Fq2, G1Affine, G1Projective, G2Affine, G2Projective,
+    Parameters::g1::Parameters as G1Parameters, Parameters::g2::Parameters as G2Parameters};
+use ark_ec::{AffineCurve, ProjectiveCurve, SWModelParameters,
+    models::short_weierstrass_jacobian::{GroupAffine, GroupProjective}};
+use ark_ff::{BigInteger384, BigInteger256, PrimeField, Field as ArkField};
 
 use rustacuda_core::DeviceCopy;
 use rustacuda_derive::DeviceCopy;
 
 use crate::utils::{u32_vec_to_u64_vec, u64_vec_to_u32_vec};
 
+
+fn bytes_to_u32_vector(bytes: &[u8]) -> Vec<u32> {
+    // Ensure the byte array length is divisible by 4
+    assert_eq!(bytes.len() % 4, 0);
+    let mut result = Vec::with_capacity(bytes.len() / 4);
+    for i in (0..bytes.len()).step_by(4) {
+        let value = (bytes[i] as u32) << 24
+            | (bytes[i + 1] as u32) << 16
+            | (bytes[i + 2] as u32) << 8
+            | (bytes[i + 3] as u32);
+        result.push(value);
+    }
+    result
+}
+
+fn get_fixed_limbs<const NUM_LIMBS: usize>(val: &[u32]) -> [u32; NUM_LIMBS] {
+    match val.len() {
+        n if n < NUM_LIMBS => {
+            let mut padded: [u32; NUM_LIMBS] = [0; NUM_LIMBS];
+            padded[..val.len()].copy_from_slice(&val);
+            padded
+        }
+        n if n == NUM_LIMBS => val.try_into().unwrap(),
+        _ => panic!("slice has too many elements"),
+    }
+}
+
 #[derive(Debug, PartialEq, Copy, Clone)]
 #[repr(C)]
 pub struct Field<const NUM_LIMBS: usize> {
@@ -24,19 +54,41 @@ impl<const NUM_LIMBS: usize> Default for Field<NUM_LIMBS> {
     }
 }
 
-impl<const NUM_LIMBS: usize> Field<NUM_LIMBS> {
-    pub fn zero() -> Self {
+pub trait LimbsField {
+    const N_LIMBS: usize;
+
+    fn zero() -> Self;
+    fn one() -> Self;
+    fn limbs(&self) -> [u32; N_LIMBS];
+    fn from_limbs(value: &[u32]) -> Self;
+    fn to_bytes_le(&self) -> Vec<u8>;
+}
+
+impl<const NUM_LIMBS: usize> LimbsField for Field<NUM_LIMBS> {
+    const N_LIMBS: usize = NUM_LIMBS;
+
+    fn zero() -> Self {
         Field {
-            s: [0u32; NUM_LIMBS],
+            s: [0u32; N_LIMBS],
         }
     }
 
-    pub fn one() -> Self {
-        let mut s = [0u32; NUM_LIMBS];
+    fn one() -> Self {
+        let mut s: [u32; NUM_LIMBS] = [0u32; N_LIMBS];
         s[0] = 1;
         Field { s }
     }
 
+    fn limbs(&self) -> [u32; N_LIMBS] {
+        self.s
+    }
+
+    fn from_limbs(value: &[u32]) -> Self {
+        Self {
+            s: get_fixed_limbs<N_LIMBS>(value),
+        }
+    }
+
     fn to_bytes_le(&self) -> Vec<u8> {
         self.s
             .iter()
@@ -48,164 +100,88 @@ impl<const NUM_LIMBS: usize> Field<NUM_LIMBS> {
 
 pub const BASE_LIMBS: usize = 12;
 pub const SCALAR_LIMBS: usize = 8;
+pub const EXTENSION_LIMBS: usize = 2 * BASE_LIMBS;
 
 #[cfg(feature = "bn254")]
 pub const BASE_LIMBS: usize = 8;
 #[cfg(feature = "bn254")]
 pub const SCALAR_LIMBS: usize = 8;
+#[cfg(feature = "bn254")]
+pub const EXTENSION_LIMBS: usize = 2 * BASE_LIMBS;
 
 pub type BaseField = Field<BASE_LIMBS>;
 pub type ScalarField = Field<SCALAR_LIMBS>;
+pub type ExtensionField = Field<EXTENSION_LIMBS>;
 
-fn get_fixed_limbs<const NUM_LIMBS: usize>(val: &[u32]) -> [u32; NUM_LIMBS] {
-    match val.len() {
-        n if n < NUM_LIMBS => {
-            let mut padded: [u32; NUM_LIMBS] = [0; NUM_LIMBS];
-            padded[..val.len()].copy_from_slice(&val);
-            padded
-        }
-        n if n == NUM_LIMBS => val.try_into().unwrap(),
-        _ => panic!("slice has too many elements"),
-    }
-}
+pub trait ArkConvertible {
+    type ArkEquivalent;
 
-impl BaseField {
-    pub fn limbs(&self) -> [u32; BASE_LIMBS] {
-        self.s
-    }
+    fn to_ark(&self) -> Self::ArkEquivalent;
+    fn from_ark(ark: &Self::ArkEquivalent) -> Self;
+}
 
-    pub fn from_limbs(value: &[u32]) -> Self {
-        Self {
-            s: get_fixed_limbs(value),
-        }
-    }
+impl ArkConvertible for BaseField {
+    type ArkEquivalent = Fq;
 
-    pub fn to_ark(&self) -> BigInteger384 {
-        BigInteger384::new(u32_vec_to_u64_vec(&self.limbs()).try_into().unwrap())
+    fn to_ark(&self) -> Fq {
+        Fq::from_repr(BigInteger384::new(u32_vec_to_u64_vec(&self.limbs()).try_into().unwrap())).unwrap()
     }
 
-    pub fn from_ark(ark: BigInteger384) -> Self {
-        Self::from_limbs(&u64_vec_to_u32_vec(&ark.0))
+    fn from_ark(ark: &Fq) -> Self {
+        Self::from_limbs(&u64_vec_to_u32_vec(&ark.0.0))
     }
 }
 
-impl ScalarField {
-    pub fn limbs(&self) -> [u32; SCALAR_LIMBS] {
-        self.s
-    }
+impl ArkConvertible for ScalarField {
+    type ArkEquivalent = BigInteger256;
 
-    pub fn to_ark(&self) -> BigInteger256 {
+    fn to_ark(&self) -> BigInteger256 {
         BigInteger256::new(u32_vec_to_u64_vec(&self.limbs()).try_into().unwrap())
     }
 
-    pub fn from_ark(ark: BigInteger256) -> Self {
-        Self::from_limbs(&u64_vec_to_u32_vec(&ark.0))
-    }
-
-    pub fn to_ark_transmute(&self) -> BigInteger256 {
-        unsafe { transmute(*self) }
-    }
-
-    pub fn from_ark_transmute(v: BigInteger256) -> ScalarField {
-        unsafe { transmute(v) }
+    fn from_ark(ark: &BigInteger256) -> Self {
+        Self::from_limbs(&u64_vec_to_u32_vec(&ark.0.0))
     }
 }
 
-#[derive(Debug, Clone, Copy, DeviceCopy)]
-#[repr(C)]
-pub struct Point {
-    pub x: BaseField,
-    pub y: BaseField,
-    pub z: BaseField,
-}
+impl ArkConvertible for ExtensionField {
+    type ArkEquivalent = Fq2;
 
-impl Default for Point {
-    fn default() -> Self {
-        Point::zero()
-    }
-}
-
-impl Point {
-    pub fn zero() -> Self {
-        Point {
-            x: BaseField::zero(),
-            y: BaseField::one(),
-            z: BaseField::zero(),
-        }
-    }
-
-    pub fn infinity() -> Self {
-        Self::zero()
+    fn to_ark(&self) -> Fq2 {
+        let c0 = BaseField::from_limbs(&self.s[..BASE_LIMBS]).to_ark();
+        let c1 = BaseField::from_limbs(&self.s[BASE_LIMBS..]).to_ark();
+        Fq2::new(c0, c1)
     }
 
-    pub fn to_ark(&self) -> G1Projective {
-        //TODO: generic conversion
-        self.to_ark_affine().into_projective()
-    }
-
-    pub fn to_ark_affine(&self) -> G1Affine {
-        //TODO: generic conversion
-        use ark_ff::Field;
-        use std::ops::Mul;
-        let proj_x_field = Fq::from_le_bytes_mod_order(&self.x.to_bytes_le());
-        let proj_y_field = Fq::from_le_bytes_mod_order(&self.y.to_bytes_le());
-        let proj_z_field = Fq::from_le_bytes_mod_order(&self.z.to_bytes_le());
-        let inverse_z = proj_z_field.inverse().unwrap();
-        let aff_x = proj_x_field.mul(inverse_z);
-        let aff_y = proj_y_field.mul(inverse_z);
-        G1Affine::new(aff_x, aff_y, false)
-    }
-
-    pub fn from_ark(ark: G1Projective) -> Point {
-        use ark_ff::Field;
-        let z_inv = ark.z.inverse().unwrap();
-        let z_invsq = z_inv * z_inv;
-        let z_invq3 = z_invsq * z_inv;
-        Point {
-            x: BaseField::from_ark((ark.x * z_invsq).into_repr()),
-            y: BaseField::from_ark((ark.y * z_invq3).into_repr()),
-            z: BaseField::one(),
-        }
-    }
-}
-
-extern "C" {
-    fn eq(point1: *const Point, point2: *const Point) -> c_uint;
-}
-
-impl PartialEq for Point {
-    fn eq(&self, other: &Self) -> bool {
-        unsafe { eq(self, other) != 0 }
+    fn from_ark(ark: &Fq2) -> Self {
+        let re_part = get_fixed_limbs<BASE_LIMBS>(&u64_vec_to_u32_vec(&ark.c0.0));
+        let im_part = get_fixed_limbs<BASE_LIMBS>(&u64_vec_to_u32_vec(&ark.c1.0));
+        Self::from_limbs(&[re_part, im_part].concat())
     }
 }
 
 #[derive(Debug, PartialEq, Clone, Copy, DeviceCopy)]
 #[repr(C)]
-pub struct PointAffineNoInfinity {
-    pub x: BaseField,
-    pub y: BaseField,
+pub struct PointAffineNoInfinity<F> {
+    pub x: F,
+    pub y: F,
 }
 
-impl Default for PointAffineNoInfinity {
+impl<F: LimbsField> Default for PointAffineNoInfinity<F> {
     fn default() -> Self {
         PointAffineNoInfinity {
-            x: BaseField::zero(),
-            y: BaseField::zero(),
+            x: F::zero(),
+            y: F::zero(),
         }
     }
 }
 
-impl PointAffineNoInfinity {
-    // TODO: generics
-    ///From u32 limbs x,y
+impl<F: ArkConvertible + LimbsField> PointAffineNoInfinity<F> {
+    // From u32 limbs x,y
     pub fn from_limbs(x: &[u32], y: &[u32]) -> Self {
         PointAffineNoInfinity {
-            x: BaseField {
-                s: get_fixed_limbs(x),
-            },
-            y: BaseField {
-                s: get_fixed_limbs(y),
-            },
+            x: F::from_limbs(x),
+            y: F::from_limbs(y),
         }
     }
 
@@ -213,76 +189,113 @@ impl PointAffineNoInfinity {
         [self.x.limbs(), self.y.limbs()].concat()
     }
 
-    pub fn to_projective(&self) -> Point {
+    pub fn to_projective(&self) -> Point<F> {
         Point {
             x: self.x,
             y: self.y,
-            z: BaseField::one(),
+            z: F::one(),
         }
     }
 
-    pub fn to_ark(&self) -> G1Affine {
-        G1Affine::new(Fq::new(self.x.to_ark()), Fq::new(self.y.to_ark()), false)
+    fn to_ark_internal<ArkParameters: SWModelParameters<BaseField = F::ArkEquivalent>>(&self) -> GroupAffine<ArkParameters> {
+        GroupAffine<ArkParameters>::new(self.x.to_ark(), self.y.to_ark(), false)
+    }
+    
+    fn from_ark_internal<ArkParameters: SWModelParameters<BaseField = F::ArkEquivalent>>(aff_ark: &GroupAffine<ArkParameters>) -> Self {
+        PointAffineNoInfinity {
+            x: F::from_ark(&aff_ark.x),
+            y: F::from_ark(&aff_ark.y),
+        }
     }
+}
 
-    pub fn to_ark_repr(&self) -> G1Affine {
-        G1Affine::new(
-            Fq::from_repr(self.x.to_ark()).unwrap(),
-            Fq::from_repr(self.y.to_ark()).unwrap(),
-            false,
-        )
+impl ArkConvertible for PointAffineNoInfinity<BaseField> {
+    type ArkEquivalent = G1Affine;
+
+    fn to_ark(&self) -> Self::ArkEquivalent {
+        self.to_ark_internal::<G1Parameters>()
     }
 
-    pub fn from_ark(p: &G1Affine) -> Self {
-        PointAffineNoInfinity {
-            x: BaseField::from_ark(p.x.into_repr()),
-            y: BaseField::from_ark(p.y.into_repr()),
-        }
+    fn from_ark(ark: &Self::ArkEquivalent) -> Self {
+        Self::from_ark_internal::<G1Parameters>(ark)
     }
 }
 
-impl Point {
-    // TODO: generics
+impl ArkConvertible for PointAffineNoInfinity<ExtensionField> {
+    type ArkEquivalent = G2Affine;
+
+    fn to_ark(&self) -> Self::ArkEquivalent {
+        self.to_ark_internal::<G2Parameters>()
+    }
+
+    fn from_ark(ark: &ArkEquivalent) -> Self {
+        Self::from_ark_internal::<G2Parameters>(ark)
+    }
+}
+
+#[derive(Debug, Clone, Copy, DeviceCopy)]
+#[repr(C)]
+pub struct Point<F> {
+    pub x: F,
+    pub y: F,
+    pub z: F,
+}
+
+impl<F: ArkConvertible + LimbsField> Point<F> {
+    pub fn zero() -> Self {
+        Point {
+            x: F::zero(),
+            y: F::one(),
+            z: F::zero(),
+        }
+    }
+
+    pub fn infinity() -> Self {
+        Self::zero()
+    }
 
     pub fn from_limbs(x: &[u32], y: &[u32], z: &[u32]) -> Self {
         Point {
-            x: BaseField {
-                s: get_fixed_limbs(x),
-            },
-            y: BaseField {
-                s: get_fixed_limbs(y),
-            },
-            z: BaseField {
-                s: get_fixed_limbs(z),
-            },
+            x: F::from_limbs(x),
+            y: F::from_limbs(y),
+            z: F::from_limbs(z),
         }
     }
 
-    pub fn from_xy_limbs(value: &[u32]) -> Point {
+    pub fn from_xy_limbs(value: &[u32]) -> Self {
         let l = value.len();
         assert_eq!(l, 3 * BASE_LIMBS, "length must be 3 * {}", BASE_LIMBS);
         Point {
-            x: BaseField {
-                s: value[..BASE_LIMBS].try_into().unwrap(),
-            },
-            y: BaseField {
-                s: value[BASE_LIMBS..BASE_LIMBS * 2].try_into().unwrap(),
-            },
-            z: BaseField {
-                s: value[BASE_LIMBS * 2..].try_into().unwrap(),
-            },
+            x: F::from_limbs(&value[..BASE_LIMBS]),
+            y: F::from_limbs(&value[BASE_LIMBS..BASE_LIMBS * 2]),
+            z: F::from_limbs(&value[BASE_LIMBS * 2..]),
         }
     }
 
-    pub fn to_affine(&self) -> PointAffineNoInfinity {
-        let ark_affine = self.to_ark_affine();
-        PointAffineNoInfinity {
-            x: BaseField::from_ark(ark_affine.x.into_repr()),
-            y: BaseField::from_ark(ark_affine.y.into_repr()),
+    fn to_ark_affine_internal<ArkParameters: SWModelParameters<BaseField = F::ArkEquivalent>>(&self) -> GroupAffine<ArkParameters> {
+        let proj_x_field = self.x.to_ark();
+        let proj_y_field = self.y.to_ark();
+        let proj_z_field = self.z.to_ark();
+        let inverse_z = proj_z_field.inverse().unwrap();
+        let aff_x = proj_x_field.mul(inverse_z);
+        let aff_y = proj_y_field.mul(inverse_z);
+        GroupAffine<ArkParameters>::new(aff_x, aff_y, false)
+    }
+    
+    fn to_ark_internal<ArkParameters: SWModelParameters<BaseField = F::ArkEquivalent>>(&self) -> GroupProjective<ArkParameters> {
+        self.to_ark_affine_internal::<ArkParameters>().into_projective()
+    }
+    
+    fn from_ark_internal<ArkParameters: SWModelParameters<BaseField = F::ArkEquivalent>>(ark_proj: &GroupProjective<ArkParameters>) -> Self {
+        let ark_affine = ark_proj.into_affine();
+        Self {
+            x: F::from_ark(&ark_affine.x),
+            y: F::from_ark(&ark_affine.y),
+            z: F::from_ark(&ark_affine.z),
         }
     }
 
-    pub fn to_xy_strip_z(&self) -> PointAffineNoInfinity {
+    pub fn to_xy_strip_z(&self) -> PointAffineNoInfinity<F> {
         PointAffineNoInfinity {
             x: self.x,
             y: self.y,
@@ -290,11 +303,55 @@ impl Point {
     }
 }
 
-impl ScalarField {
-    pub fn from_limbs(value: &[u32]) -> ScalarField {
-        ScalarField {
-            s: get_fixed_limbs(value),
-        }
+impl ArkConvertible for Point<BaseField> {
+    type ArkEquivalent = G1Projective;
+
+    fn to_ark(&self) -> Self::ArkEquivalent {
+        self.to_ark_internal::<G1Parameters>()
+    }
+
+    fn from_ark(ark_proj: &Self::ArkEquivalent) -> Self {
+        Self::from_ark_internal::<G1Parameters>(ark)
+    }
+}
+
+impl<F: LimbsField + ArkConvertible> Default for Point<F> {
+    fn default() -> Self {
+        Point::zero()
+    }
+}
+
+impl Point<BaseField> {
+    pub fn to_ark_affine(&self) -> G1Affine {
+        self.to_ark_affine_internal::<G1Parameters>()
+    }
+}
+
+impl ArkConvertible for Point<ExtensionField> {
+    type ArkEquivalent = G2Projective;
+
+    fn to_ark(&self) -> Self::ArkEquivalent {
+        self.to_ark_internal::<G2Parameters>()
+    }
+
+    fn from_ark(ark_proj: &Self::ArkEquivalent) -> Self {
+        Self::from_ark_internal::<G2Parameters>(ark_proj)
+    }
+}
+
+impl Point<ExtensionField> {
+    pub fn to_ark_affine(&self) -> G2Affine {
+        self.to_ark_affine_internal::<G2Parameters>()
+    }
+}
+
+extern "C" {
+    fn eq(point1: *const Point<BaseField>, point2: *const Point<BaseField>) -> c_uint;
+}
+
+impl PartialEq for Point<BaseField> {
+    fn eq(&self, other: &Self) -> bool {
+        unsafe { eq(self, other) != 0 }
     }
 }
 
@@ -302,8 +359,17 @@ impl ScalarField {
 #[cfg(test)]
 mod tests {
     use ark_bls12_381::Fr;
+    use std::mem::transmute;
+
+    use crate::{utils::{u32_vec_to_u64_vec, u64_vec_to_u32_vec}, field::{Point, ScalarField, LimbsField, ArkConvertible}};
 
-    use crate::{utils::{u32_vec_to_u64_vec, u64_vec_to_u32_vec}, field::{Point, ScalarField}};
+    fn to_ark_transmute(v: &ScalarField) -> BigInteger256 {
+        unsafe { transmute(*v) }
+    }
+    
+    pub fn from_ark_transmute(v: BigInteger256) -> ScalarField {
+        unsafe { transmute(v) }
+    }
 
     #[test]
     fn test_ark_scalar_convert() {
@@ -311,10 +377,10 @@ mod tests {
         let scalar = ScalarField::from_limbs(&limbs);
         assert_eq!(
             scalar.to_ark(),
-            scalar.to_ark_transmute(),
+            to_ark_transmute(&scalar),
             "{:08X?} {:08X?}",
             scalar.to_ark(),
-            scalar.to_ark_transmute()
+            to_ark_transmute(&scalar)
         )
     }
 
diff --git a/src/lib.rs b/src/lib.rs
index 0580267..5798326 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -2,7 +2,7 @@ use std::ffi::{c_int, c_uint};
 
 use rand::{rngs::StdRng, RngCore, SeedableRng};
 
-use field::*;
+use field::{BaseField, ScalarField, Point as PointGeneric, PointAffineNoInfinity as PointAffineGeneric, LimbsField, ArkConvertible};
 use ark_bls12_381::{Fr, G1Affine, G1Projective};
 use ark_ff::PrimeField;
 use ark_std::UniformRand;
@@ -14,6 +14,9 @@ use rustacuda::memory::{DeviceBox, CopyDestination, DeviceCopy};
 pub mod field;
 pub mod utils;
 
+type Point = PointGeneric<BaseField>;
+type PointAffineNoInfinity = PointAffineGeneric<BaseField>;
+
 extern "C" {
     fn msm_cuda(
         out: *mut Point,
@@ -753,19 +756,19 @@ pub fn generate_random_points(
     mut rng: Box<dyn RngCore>,
 ) -> Vec<PointAffineNoInfinity> {
     (0..count)
-        .map(|_| Point::from_ark(G1Projective::rand(&mut rng)).to_xy_strip_z())
+        .map(|_| Point::from_ark(&G1Projective::rand(&mut rng)).to_xy_strip_z())
         .collect()
 }
 
 pub fn generate_random_points_proj(count: usize, mut rng: Box<dyn RngCore>) -> Vec<Point> {
     (0..count)
-        .map(|_| Point::from_ark(G1Projective::rand(&mut rng)))
+        .map(|_| Point::from_ark(&G1Projective::rand(&mut rng)))
         .collect()
 }
 
 pub fn generate_random_scalars(count: usize, mut rng: Box<dyn RngCore>) -> Vec<ScalarField> {
     (0..count)
-        .map(|_| ScalarField::from_ark(Fr::rand(&mut rng).into_repr()))
+        .map(|_| ScalarField::from_ark(&Fr::rand(&mut rng).into_repr()))
         .collect()
 }
 
@@ -802,7 +805,7 @@ pub(crate) mod tests {
     use ark_ec::{msm::VariableBaseMSM, AffineCurve, ProjectiveCurve};
     use ark_ff::{FftField, Field, Zero, PrimeField};
 
-    use crate::{field::*, *};
+    // use crate::{field::*, *};
 
     fn random_points_ark_proj(nof_elements: usize) -> Vec<G1Projective> {
         let mut rng = ark_std::rand::thread_rng();
@@ -877,7 +880,7 @@ pub(crate) mod tests {
 
             let msm_result = msm(&points, &scalars, 0);
 
-            let point_r_ark: Vec<_> = points.iter().map(|x| x.to_ark_repr()).collect();
+            let point_r_ark: Vec<_> = points.iter().map(|x| x.to_ark()).collect();
             let scalars_r_ark: Vec<_> = scalars.iter().map(|x| x.to_ark()).collect();
 
             let msm_result_ark = VariableBaseMSM::multi_scalar_mul(&point_r_ark, &scalars_r_ark);
@@ -886,7 +889,7 @@ pub(crate) mod tests {
             assert_eq!(msm_result.to_ark(), msm_result_ark);
             assert_eq!(
                 msm_result.to_ark_affine(),
-                Point::from_ark(msm_result_ark).to_ark_affine()
+                Point::from_ark(&msm_result_ark).to_ark_affine()
             );
         }
     }
@@ -901,13 +904,13 @@ pub(crate) mod tests {
                 let points_batch = generate_random_points(msm_size * batch_size, get_rng(seed));
                 let scalars_batch = generate_random_scalars(msm_size * batch_size, get_rng(seed));
 
-                let point_r_ark: Vec<_> = points_batch.iter().map(|x| x.to_ark_repr()).collect();
+                let point_r_ark: Vec<_> = points_batch.iter().map(|x| x.to_ark()).collect();
                 let scalars_r_ark: Vec<_> = scalars_batch.iter().map(|x| x.to_ark()).collect();
 
                 let expected: Vec<_> = point_r_ark
                     .chunks(msm_size)
                     .zip(scalars_r_ark.chunks(msm_size))
-                    .map(|p| Point::from_ark(VariableBaseMSM::multi_scalar_mul(p.0, p.1)))
+                    .map(|p| Point::from_ark(&VariableBaseMSM::multi_scalar_mul(p.0, p.1)))
                     .collect();
 
                 let result = msm_batch(&points_batch, &scalars_batch, batch_size, 0);
@@ -1431,7 +1434,7 @@ pub(crate) mod tests {
             |row_num| { (0..test_size).map( 
                 |col_num| {
                     let pow: [u64; 1] = [(row_num * col_num).try_into().unwrap()];
-                    ScalarField::from_ark(Fr::pow(&rou, &pow).into_repr())
+                    ScalarField::from_ark(&Fr::pow(&rou, &pow).into_repr())
                 }).collect::<Vec<ScalarField>>()
             }).flatten().collect::<Vec<_>>();
         let vector: Vec<ScalarField> = generate_random_scalars(test_size, get_rng(seed));
diff --git a/src/utils.rs b/src/utils.rs
index 14cdd16..8fe9975 100644
--- a/src/utils.rs
+++ b/src/utils.rs
@@ -41,7 +41,7 @@ mod tests {
     fn test_u32_vec_to_u64_vec() {
         let arr_u32 = [1, 0x0fffffff, 3, 0x2fffffff, 5, 0x4fffffff, 7, 0x6fffffff];
 
-        let s = ScalarField::from_ark_transmute(BigInteger256::new(
+        let s = from_ark_transmute(BigInteger256::new(
             u32_vec_to_u64_vec(&arr_u32).try_into().unwrap(),
         ))
         .limbs();
